/* Parser.Yaml
 *
 * Copyright (C) 2017 Pontus Ã–stlund
 *
 * Mozilla Public License Version 2.0
 */

#pike __REAL_VERSION__

#require constant(@module@)

//! @ignore
inherit @module@;
//! @endignore

//! @decl typedef mapping(string:mixed) EventData
typedef mapping(string:mixed) EventData;

#define SCALAR_TAG_IS(event, what) (event->tag == what)

#define IS_NOT_IMPLICIT(event)                     \
  (!event->quoted_implicit && !event->plain_implicit)

#define IS_NOT_QUOTED(event)                       \
  (event->style == PLAIN_SCALAR_STYLE ||           \
   event->style == ANY_SCALAR_STYLE)

#define SCALAR_IS_QUOTED(event)                    \
  (event->style == SINGLE_QUOTED_SCALAR_STYLE ||   \
   event->style == DOUBLE_QUOTED_SCALAR_STYLE)


//! Decode the YAML data in @[input] into an internal Pike structure.
//!
//! This is the same as:
//!
//! @code
//! Parser.Yaml.Parser p = Parser.Yaml.Parser();
//! p->set_input_string(my_yaml_data);
//! mixed res = p->deconstruct();
//! @endcode
public mixed decode(string(8bit) input)
{
  Parser p = Parser();
  p->set_input_string(input);
  return p->deconstruct();
}


//! Decode the YAML data in the @[file] into an internal Pike structure.
//!
//! This is the same as:
//!
//! @code
//! Parser.Yaml.Parser p = Parser.Yaml.Parser();
//! p->set_input_file(my_yaml_file);
//! mixed res = p->deconstruct();
//! @endcode
public mixed decode_file(string(8bit) file)
{
  Parser p = Parser();
  p->set_input_file(file);
  return p->deconstruct();
}


//! Yaml parser class
class Parser {
  inherit _Parser;

  private EventData next_event;
  private int next_event_type;
  private mapping anchors = ([]);

  //! Move the parser to the next event. If @[peek_event()] has been called
  //! that event type will be returned.
  //!
  //! @seealso
  //!  @[get_event()], @[peek_event()]
  //!
  //! @returns
  //!  The current event type. This is any of the @[ALIAS_EVENT],
  //!  @[DOCUMENT_END_EVENT], @[DOCUMENT_START_EVENT], @[MAPPING_END_EVENT],
  //!  @[MAPPING_START_EVENT], @[NO_EVENT], @[SCALAR_EVENT],
  //!  @[SEQUENCE_END_EVENT], @[SEQUENCE_START_EVENT], @[STREAM_END_EVENT]
  //!  or @[STREAM_START_EVENT] constants.
  //!
  //!  To get a string representation of the event use the @[EVENT_TYPE_TO_STR]
  //!  mapping.
  //!
  //! @code
  //! EVENT_TYPE_TO_STR[return_value_from_parse]
  //! @endcode
  int parse()
  {
    if (next_event_type) {
      int t = next_event_type;
      next_event_type = 0;
      return t;
    }

    // No one bothered using it
    if (next_event) {
      next_event = 0;
    }

    return ::parse();
  }

  //! Returns the current event data structure. If @[peek_event()] has been
  //! called the event from that call will be returned.
  //!
  //! @seealso
  //!  @[peek_event()], @[parse()]
  //!
  //! @returns
  //!  A mapping of some sort. It has different members depending on what type
  //!  of event it is.
  EventData get_event()
  {
    if (next_event) {
      EventData t = copy_value(next_event);
      next_event = 0;
      return t;
    }

    EventData e = ::get_event();
    convert_scalar_type(e);
    return e;
  }

  //! Peek at the next event. This will move the parser one step, but the result
  //! of a call to this function will be cached and returned from the next call
  //! to @[parse()]. So beware that multiple consecutive calls to this method
  //! will move the cursor beyond what @[parse()] or @[get_event()] will return.
  EventData peek_event()
  {
    next_event_type = ::parse();
    next_event = ::get_event();
    convert_scalar_type(next_event);
    return next_event;
  }

  //! Converts the entire document into a Pike data structure.
  //!
  //! @seealso
  //!  @[decode()], @[decode_file()]
  mixed deconstruct()
  {
    EventData e, n;
    mixed out;
    mixed curr;
    array docs;

    while (int t = parse()) {
      // werror(">>> %s\n", EVENT_TYPE_TO_STR[t]);
      switch (t)
      {
        case DOCUMENT_END_EVENT:
          EventData tmp = peek_event();

          if (!out) {
            out = copy_value(curr);
          }
          else {
            if (!docs) {
              docs = ({ out });
            }
            docs += ({ curr });
          }

          break;

        case MAPPING_START_EVENT:
          curr = deconstruct_mapping();
          break;

        case SEQUENCE_START_EVENT:
          curr = deconstruct_sequence();
          break;

        case SCALAR_EVENT:
          e = get_event();

          if (arrayp(curr)) {
            curr += ({ e->value });
          }
          else if (mappingp(curr)) {
            n = peek_event();
            // Skip the peeked event
            parse();

            switch (n->type)
            {
              case SCALAR_EVENT:
                curr[e->value] = n->value;
                break;

              case SEQUENCE_START_EVENT:
                curr[e->value] = deconstruct_sequence();
                break;

              case MAPPING_START_EVENT:
                curr[e->value] = deconstruct_mapping();
                break;
            }
          }
          else if (!curr) {
            curr = e->value;
          }
          break;
      }
    }

    return docs || out;
  }

  protected array deconstruct_sequence()
  {
    // werror(">>> deconstruct_sequence()\n");
    EventData e;
    array out = ({});

    while (parse()) {
      e = get_event();

      if (e->type == SEQUENCE_END_EVENT) {
        break;
      }

      switch (e->type)
      {
        case MAPPING_START_EVENT:
          out += ({ deconstruct_mapping() });
          break;

        case SEQUENCE_START_EVENT:
          out += ({ deconstruct_sequence() });
          break;

        case ALIAS_EVENT:
          out += ({ anchors[e->anchor] });
          break;

        default:
          out += ({ e->value });
          break;
      }
    }
    // werror("<<< deconstruct_sequence()\n");
    return out;
  }

  protected mapping deconstruct_mapping()
  {
    // werror(">>> deconstruct_mapping()\n");
    EventData e, n;
    mapping out = ([]);

    while (parse()) {
      e = get_event();

      if (e->type == MAPPING_END_EVENT) {
        break;
      }

      if (e->type == SEQUENCE_START_EVENT) {
        e->value = deconstruct_sequence();
      }

      n = peek_event();
      parse();

      switch (n->type)
      {
        case SEQUENCE_START_EVENT:
          out[e->value] = deconstruct_sequence();
          break;

        case MAPPING_START_EVENT:
          out[e->value] = deconstruct_mapping();
          break;

        case ALIAS_EVENT:
          out[e->value] = anchors[n->anchor];
          break;

        default:
          out[e->value] = n->value;
          break;
      }
    }
    // werror("<<< deconstruct_mapping()\n");
    return out;
  }

  //! @ignore

  //! Convert @tt{value@} in @[e] to it's proper data type
  //!
  //! NOTE: This method has side effects, it changes the value property in @[e].
  protected void convert_scalar_type(EventData e)
  {
    // werror("e (%s): %O\n", EVENT_TYPE_TO_STR[e->type], e);

    if (e->type != SCALAR_EVENT) {
      return;
    }

    string d = e->value;
    string lcd = lower_case(d);
    mixed val;

    if (SCALAR_IS_QUOTED(e)) {
      // Do nothing, explicit string
    }
    else if (!zero_type(val = scalar_is_null(e))) {
      e->value = val;
    }
    else if (!zero_type(val = scalar_is_bool(e))) {
      e->value = val;
    }
    else if (!zero_type(val = scalar_is_numeric(e))) {
      e->value = val;
    }

    if (e->anchor) {
      anchors[e->anchor] = e->value;
    }
  }

  //!
  protected Val.Null scalar_is_null(EventData e)
  {
    if (e->quoted_implicit) {
      return UNDEFINED;
    }

    if (e->plain_implicit && (< "~", "null" >)[lower_case(e->value)]) {
      return Val.null;
    }

    return e->value == NULL_TAG ? Val.null : UNDEFINED;
  }

  //!
  protected Val.Boolean scalar_is_bool(EventData e)
  {
    if (SCALAR_TAG_IS(e, BOOL_TAG) || IS_NOT_QUOTED(e)) {
      if ((< "y", "yes", "true", "on" >)[lower_case(e->value)]) {
        return Val.true;
      }

      if ((< "n", "no", "false", "off" >)[lower_case(e->value)]) {
        return Val.false;
      }
    }

    return UNDEFINED;
  }

  //!
  protected mixed scalar_is_numeric(EventData e)
  {
    string v = String.trim_all_whites(e->value);

    if (!sizeof(v) || SCALAR_IS_QUOTED(e)) {
      return UNDEFINED;
    }

    string lcv = lower_case(v);

    if (lcv == ".inf") {
      return Math.inf;
    }

    if (lcv == ".nan") {
      return Math.nan;
    }

    string prefix;

    if (lcv[0] == '+' || lcv[0] == '-') {
      prefix = lcv[0..0];
      lcv = lcv[1..];
    }

    multiset int_range = (< '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' >);

    if (!int_range[lcv[0]] && lcv[0] != '.') {
      return UNDEFINED;
    }

    string sentinel = lcv + "\0\0";
    int len = sizeof(lcv);
    int alphas = 0;
    int dots = 0;
    int lodash = 0;
    int prev;


    for (int i; i < len; i++) {
      int c = lcv[i];

      if (c == '.') {
        dots += 1;
        // Can't be a numeric value
        if (dots > 1) {
          return UNDEFINED;
        }
      }
      else if (c == '_') {
        if (zero_type(prev) || !int_range[prev]) {
          return UNDEFINED;
        }

        lodash += 1;
      }
      else if (c == 'x') {
        if (sentinel[i-1] != '0') {
          return UNDEFINED;
        }
        // Hexadecimal, break early
        break;
      }
      else if (c == 'e') {
        if (!dots || (sentinel[i+1] != '+' && !int_range[sentinel[i+2]])) {
          return UNDEFINED;
        }
        i += 2;
        c = lcv[i];
      }
      else if (!int_range[c]) {
        alphas += 1;
      }

      prev = c;
    }

    if (!alphas) {
      if (lodash) {
        lcv -= "_";
      }

      // Octal or hexadecimal. Dunno if to convert or if it can be natively
      // represented as any of this number types. Now it's converted to decimal
      // number.
      if (sizeof(lcv) > 1 && lcv[0] == '0') {
        if (lcv[1] == 'x') {
          // error("Unahandled hexadecimal number.\n");
          return hex_to_dec(lcv);
        }
        else {
          return oct_to_dec(lcv);
        }
      }

      if (prefix) {
        lcv = prefix + lcv;
      }

      if (dots) {
        return (float) lcv;
      }
      else {
        return (int) lcv;
      }
    }

    return UNDEFINED;
  }


  int oct_to_dec(string o)
  {
    int len = sizeof(o);
    int x;

    for (int i = 0, j = len-1; i < len; i++, --j) {
      int c = (int)o[i..i];
      x += c*pow(8, j);
    }

    return x;
  }


  int hex_to_dec(string h)
  {
    string chars = "0123456789abcdef";
    h = lower_case(h[2..]);
    int len = sizeof(h);
    int x;

    for (int i, j = len-1; i < len; i++, --j) {
      int pos = search(chars, h[i..i]);
      x += pos * pow(16, j);
    }

    return x;
  }

  //! @endignore
}


//! ENCODING to string conversion
constant ENCODING_TO_STR = ([
  ANY_ENCODING : "ANY_ENCODING",
  UTF16BE_ENCODING : "UTF16BE_ENCODING",
  UTF16LE_ENCODING : "UTF16LE_ENCODING",
  UTF8_ENCODING : "UTF8_ENCODING",
]);

//! BREAK to string conversion
constant BREAK_TO_STR = ([
  ANY_BREAK : "ANY_BREAK",
  CRLN_BREAK : "CRLN_BREAK",
  CR_BREAK : "CR_BREAK",
  LN_BREAK : "LN_BREAK",
]);

//! ERROR_TYPE to string conversion
constant ERROR_TYPE_TO_STR = ([
  COMPOSER_ERROR : "COMPOSER_ERROR",
  EMITTER_ERROR : "EMITTER_ERROR",
  MEMORY_ERROR : "MEMORY_ERROR",
  NO_ERROR : "NO_ERROR",
  PARSER_ERROR : "PARSER_ERROR",
  READER_ERROR : "READER_ERROR",
  SCANNER_ERROR : "SCANNER_ERROR",
  WRITER_ERROR : "WRITER_ERROR",
]);

//! SCALAR_STYLE to string conversion
constant SCALAR_STYLE_TO_STR = ([
  ANY_SCALAR_STYLE : "ANY_SCALAR_STYLE",
  DOUBLE_QUOTED_SCALAR_STYLE : "DOUBLE_QUOTED_SCALAR_STYLE",
  FOLDED_SCALAR_STYLE : "FOLDED_SCALAR_STYLE",
  LITERAL_SCALAR_STYLE : "LITERAL_SCALAR_STYLE",
  PLAIN_SCALAR_STYLE : "PLAIN_SCALAR_STYLE",
  SINGLE_QUOTED_SCALAR_STYLE : "SINGLE_QUOTED_SCALAR_STYLE",
]);

//! SEQUENCE_STYLE to string conversion
constant SEQUENCE_STYLE_TO_STR = ([
  ANY_SEQUENCE_STYLE : "ANY_SEQUENCE_STYLE",
  BLOCK_SEQUENCE_STYLE : "BLOCK_SEQUENCE_STYLE",
  FLOW_SEQUENCE_STYLE : "FLOW_SEQUENCE_STYLE",
]);

//! MAPPING_STYLE to string conversion
constant MAPPING_STYLE_TO_STR = ([
  ANY_MAPPING_STYLE : "ANY_MAPPING_STYLE",
  BLOCK_MAPPING_STYLE : "BLOCK_MAPPING_STYLE",
  FLOW_MAPPING_STYLE : "FLOW_MAPPING_STYLE",
]);

//! TOKEN_TYPE to string conversion
constant TOKEN_TYPE_TO_STR = ([
  ALIAS_TOKEN : "ALIAS_TOKEN",
  ANCHOR_TOKEN : "ANCHOR_TOKEN",
  BLOCK_END_TOKEN : "BLOCK_END_TOKEN",
  BLOCK_ENTRY_TOKEN : "BLOCK_ENTRY_TOKEN",
  BLOCK_MAPPING_START_TOKEN : "BLOCK_MAPPING_START_TOKEN",
  BLOCK_SEQUENCE_START_TOKEN : "BLOCK_SEQUENCE_START_TOKEN",
  DOCUMENT_END_TOKEN : "DOCUMENT_END_TOKEN",
  DOCUMENT_START_TOKEN : "DOCUMENT_START_TOKEN",
  FLOW_ENTRY_TOKEN : "FLOW_ENTRY_TOKEN",
  FLOW_MAPPING_END_TOKEN : "FLOW_MAPPING_END_TOKEN",
  FLOW_MAPPING_START_TOKEN : "FLOW_MAPPING_START_TOKEN",
  FLOW_SEQUENCE_END_TOKEN : "FLOW_SEQUENCE_END_TOKEN",
  FLOW_SEQUENCE_START_TOKEN : "FLOW_SEQUENCE_START_TOKEN",
  KEY_TOKEN : "KEY_TOKEN",
  NO_TOKEN : "NO_TOKEN",
  SCALAR_TOKEN : "SCALAR_TOKEN",
  STREAM_END_TOKEN : "STREAM_END_TOKEN",
  STREAM_START_TOKEN : "STREAM_START_TOKEN",
  TAG_DIRECTIVE_TOKEN : "TAG_DIRECTIVE_TOKEN",
  TAG_TOKEN : "TAG_TOKEN",
  VALUE_TOKEN : "VALUE_TOKEN",
  VERSION_DIRECTIVE_TOKEN : "VERSION_DIRECTIVE_TOKEN",
]);

//! EVENT_TYPE to string conversion
constant EVENT_TYPE_TO_STR = ([
  ALIAS_EVENT : "ALIAS_EVENT",
  DOCUMENT_END_EVENT : "DOCUMENT_END_EVENT",
  DOCUMENT_START_EVENT : "DOCUMENT_START_EVENT",
  MAPPING_END_EVENT : "MAPPING_END_EVENT",
  MAPPING_START_EVENT : "MAPPING_START_EVENT",
  NO_EVENT : "NO_EVENT",
  SCALAR_EVENT : "SCALAR_EVENT",
  SEQUENCE_END_EVENT : "SEQUENCE_END_EVENT",
  SEQUENCE_START_EVENT : "SEQUENCE_START_EVENT",
  STREAM_END_EVENT : "STREAM_END_EVENT",
  STREAM_START_EVENT : "STREAM_START_EVENT",
]);

//! NODE_TYPE to string conversion
constant NODE_TYPE_TO_STR = ([
  MAPPING_NODE : "MAPPING_NODE",
  NO_NODE : "NO_NODE",
  SCALAR_NODE : "SCALAR_NODE",
  SEQUENCE_NODE : "SEQUENCE_NODE",
]);

//! PARSER_STATE to string conversion
constant PARSER_STATE_TO_STR = ([
  PARSE_BLOCK_MAPPING_FIRST_KEY_STATE : "PARSE_BLOCK_MAPPING_FIRST_KEY_STATE",
  PARSE_BLOCK_MAPPING_KEY_STATE : "PARSE_BLOCK_MAPPING_KEY_STATE",
  PARSE_BLOCK_MAPPING_VALUE_STATE : "PARSE_BLOCK_MAPPING_VALUE_STATE",
  PARSE_BLOCK_NODE_OR_INDENTLESS_SEQUENCE_STATE : "PARSE_BLOCK_NODE_OR_INDENTLESS_SEQUENCE_STATE",
  PARSE_BLOCK_NODE_STATE : "PARSE_BLOCK_NODE_STATE",
  PARSE_BLOCK_SEQUENCE_ENTRY_STATE : "PARSE_BLOCK_SEQUENCE_ENTRY_STATE",
  PARSE_BLOCK_SEQUENCE_FIRST_ENTRY_STATE : "PARSE_BLOCK_SEQUENCE_FIRST_ENTRY_STATE",
  PARSE_DOCUMENT_CONTENT_STATE : "PARSE_DOCUMENT_CONTENT_STATE",
  PARSE_DOCUMENT_END_STATE : "PARSE_DOCUMENT_END_STATE",
  PARSE_DOCUMENT_START_STATE : "PARSE_DOCUMENT_START_STATE",
  PARSE_END_STATE : "PARSE_END_STATE",
  PARSE_FLOW_MAPPING_EMPTY_VALUE_STATE : "PARSE_FLOW_MAPPING_EMPTY_VALUE_STATE",
  PARSE_FLOW_MAPPING_FIRST_KEY_STATE : "PARSE_FLOW_MAPPING_FIRST_KEY_STATE",
  PARSE_FLOW_MAPPING_KEY_STATE : "PARSE_FLOW_MAPPING_KEY_STATE",
  PARSE_FLOW_MAPPING_VALUE_STATE : "PARSE_FLOW_MAPPING_VALUE_STATE",
  PARSE_FLOW_NODE_STATE : "PARSE_FLOW_NODE_STATE",
  PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_END_STATE : "PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_END_STATE",
  PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_KEY_STATE : "PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_KEY_STATE",
  PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_VALUE_STATE : "PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_VALUE_STATE",
  PARSE_FLOW_SEQUENCE_ENTRY_STATE : "PARSE_FLOW_SEQUENCE_ENTRY_STATE",
  PARSE_FLOW_SEQUENCE_FIRST_ENTRY_STATE : "PARSE_FLOW_SEQUENCE_FIRST_ENTRY_STATE",
  PARSE_IMPLICIT_DOCUMENT_START_STATE : "PARSE_IMPLICIT_DOCUMENT_START_STATE",
  PARSE_INDENTLESS_SEQUENCE_ENTRY_STATE : "PARSE_INDENTLESS_SEQUENCE_ENTRY_STATE",
  PARSE_STREAM_START_STATE : "PARSE_STREAM_START_STATE",
]);

//! EMITTER_STATE to string conversion
constant EMITTER_STATE_TO_STR = ([
  EMIT_BLOCK_MAPPING_FIRST_KEY_STATE : "EMIT_BLOCK_MAPPING_FIRST_KEY_STATE",
  EMIT_BLOCK_MAPPING_KEY_STATE : "EMIT_BLOCK_MAPPING_KEY_STATE",
  EMIT_BLOCK_MAPPING_SIMPLE_VALUE_STATE : "EMIT_BLOCK_MAPPING_SIMPLE_VALUE_STATE",
  EMIT_BLOCK_MAPPING_VALUE_STATE : "EMIT_BLOCK_MAPPING_VALUE_STATE",
  EMIT_BLOCK_SEQUENCE_FIRST_ITEM_STATE : "EMIT_BLOCK_SEQUENCE_FIRST_ITEM_STATE",
  EMIT_BLOCK_SEQUENCE_ITEM_STATE : "EMIT_BLOCK_SEQUENCE_ITEM_STATE",
  EMIT_DOCUMENT_CONTENT_STATE : "EMIT_DOCUMENT_CONTENT_STATE",
  EMIT_DOCUMENT_END_STATE : "EMIT_DOCUMENT_END_STATE",
  EMIT_DOCUMENT_START_STATE : "EMIT_DOCUMENT_START_STATE",
  EMIT_END_STATE : "EMIT_END_STATE",
  EMIT_FIRST_DOCUMENT_START_STATE : "EMIT_FIRST_DOCUMENT_START_STATE",
  EMIT_FLOW_MAPPING_FIRST_KEY_STATE : "EMIT_FLOW_MAPPING_FIRST_KEY_STATE",
  EMIT_FLOW_MAPPING_KEY_STATE : "EMIT_FLOW_MAPPING_KEY_STATE",
  EMIT_FLOW_MAPPING_SIMPLE_VALUE_STATE : "EMIT_FLOW_MAPPING_SIMPLE_VALUE_STATE",
  EMIT_FLOW_MAPPING_VALUE_STATE : "EMIT_FLOW_MAPPING_VALUE_STATE",
  EMIT_FLOW_SEQUENCE_FIRST_ITEM_STATE : "EMIT_FLOW_SEQUENCE_FIRST_ITEM_STATE",
  EMIT_FLOW_SEQUENCE_ITEM_STATE : "EMIT_FLOW_SEQUENCE_ITEM_STATE",
  EMIT_STREAM_START_STATE : "EMIT_STREAM_START_STATE",
]);
